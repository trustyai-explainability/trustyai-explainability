// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc_predict_v2.proto

package org.kie.trustyai.connectors.kserve.v2.grpc;

public interface InferTensorContentsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:inference.InferTensorContents)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Representation for BOOL data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bool bool_contents = 1;</code>
   * @return A list containing the boolContents.
   */
  java.util.List<java.lang.Boolean> getBoolContentsList();
  /**
   * <pre>
   * Representation for BOOL data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bool bool_contents = 1;</code>
   * @return The count of boolContents.
   */
  int getBoolContentsCount();
  /**
   * <pre>
   * Representation for BOOL data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bool bool_contents = 1;</code>
   * @param index The index of the element to return.
   * @return The boolContents at the given index.
   */
  boolean getBoolContents(int index);

  /**
   * <pre>
   * Representation for INT8, INT16, and INT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated int32 int_contents = 2;</code>
   * @return A list containing the intContents.
   */
  java.util.List<java.lang.Integer> getIntContentsList();
  /**
   * <pre>
   * Representation for INT8, INT16, and INT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated int32 int_contents = 2;</code>
   * @return The count of intContents.
   */
  int getIntContentsCount();
  /**
   * <pre>
   * Representation for INT8, INT16, and INT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated int32 int_contents = 2;</code>
   * @param index The index of the element to return.
   * @return The intContents at the given index.
   */
  int getIntContents(int index);

  /**
   * <pre>
   * Representation for INT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated int64 int64_contents = 3;</code>
   * @return A list containing the int64Contents.
   */
  java.util.List<java.lang.Long> getInt64ContentsList();
  /**
   * <pre>
   * Representation for INT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated int64 int64_contents = 3;</code>
   * @return The count of int64Contents.
   */
  int getInt64ContentsCount();
  /**
   * <pre>
   * Representation for INT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated int64 int64_contents = 3;</code>
   * @param index The index of the element to return.
   * @return The int64Contents at the given index.
   */
  long getInt64Contents(int index);

  /**
   * <pre>
   * Representation for UINT8, UINT16, and UINT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated uint32 uint_contents = 4;</code>
   * @return A list containing the uintContents.
   */
  java.util.List<java.lang.Integer> getUintContentsList();
  /**
   * <pre>
   * Representation for UINT8, UINT16, and UINT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated uint32 uint_contents = 4;</code>
   * @return The count of uintContents.
   */
  int getUintContentsCount();
  /**
   * <pre>
   * Representation for UINT8, UINT16, and UINT32 data types. The size
   * must match what is expected by the tensor's shape. The contents
   * must be the flattened, one-dimensional, row-major order of the
   * tensor elements.
   * </pre>
   *
   * <code>repeated uint32 uint_contents = 4;</code>
   * @param index The index of the element to return.
   * @return The uintContents at the given index.
   */
  int getUintContents(int index);

  /**
   * <pre>
   * Representation for UINT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated uint64 uint64_contents = 5;</code>
   * @return A list containing the uint64Contents.
   */
  java.util.List<java.lang.Long> getUint64ContentsList();
  /**
   * <pre>
   * Representation for UINT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated uint64 uint64_contents = 5;</code>
   * @return The count of uint64Contents.
   */
  int getUint64ContentsCount();
  /**
   * <pre>
   * Representation for UINT64 data types. The size must match what
   * is expected by the tensor's shape. The contents must be the
   * flattened, one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated uint64 uint64_contents = 5;</code>
   * @param index The index of the element to return.
   * @return The uint64Contents at the given index.
   */
  long getUint64Contents(int index);

  /**
   * <pre>
   * Representation for FP32 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated float fp32_contents = 6;</code>
   * @return A list containing the fp32Contents.
   */
  java.util.List<java.lang.Float> getFp32ContentsList();
  /**
   * <pre>
   * Representation for FP32 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated float fp32_contents = 6;</code>
   * @return The count of fp32Contents.
   */
  int getFp32ContentsCount();
  /**
   * <pre>
   * Representation for FP32 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated float fp32_contents = 6;</code>
   * @param index The index of the element to return.
   * @return The fp32Contents at the given index.
   */
  float getFp32Contents(int index);

  /**
   * <pre>
   * Representation for FP64 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated double fp64_contents = 7;</code>
   * @return A list containing the fp64Contents.
   */
  java.util.List<java.lang.Double> getFp64ContentsList();
  /**
   * <pre>
   * Representation for FP64 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated double fp64_contents = 7;</code>
   * @return The count of fp64Contents.
   */
  int getFp64ContentsCount();
  /**
   * <pre>
   * Representation for FP64 data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated double fp64_contents = 7;</code>
   * @param index The index of the element to return.
   * @return The fp64Contents at the given index.
   */
  double getFp64Contents(int index);

  /**
   * <pre>
   * Representation for BYTES data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bytes bytes_contents = 8;</code>
   * @return A list containing the bytesContents.
   */
  java.util.List<com.google.protobuf.ByteString> getBytesContentsList();
  /**
   * <pre>
   * Representation for BYTES data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bytes bytes_contents = 8;</code>
   * @return The count of bytesContents.
   */
  int getBytesContentsCount();
  /**
   * <pre>
   * Representation for BYTES data type. The size must match what is
   * expected by the tensor's shape. The contents must be the flattened,
   * one-dimensional, row-major order of the tensor elements.
   * </pre>
   *
   * <code>repeated bytes bytes_contents = 8;</code>
   * @param index The index of the element to return.
   * @return The bytesContents at the given index.
   */
  com.google.protobuf.ByteString getBytesContents(int index);
}
